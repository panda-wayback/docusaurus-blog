<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-algorithm/工业算法/寻路算法/Flood Fill 洪水填充" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.1">
<title data-rh="true">增量式洪水填充算法 (Incremental Flood Fill Algorithm) | Panda 的技术博客</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://panda-wayback.github.io/docusaurus-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://panda-wayback.github.io/docusaurus-blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://panda-wayback.github.io/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="增量式洪水填充算法 (Incremental Flood Fill Algorithm) | Panda 的技术博客"><meta data-rh="true" name="description" content="📺 参考视频: B站视频链接"><meta data-rh="true" property="og:description" content="📺 参考视频: B站视频链接"><link data-rh="true" rel="icon" href="/docusaurus-blog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://panda-wayback.github.io/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充"><link data-rh="true" rel="alternate" href="https://panda-wayback.github.io/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充" hreflang="en"><link data-rh="true" rel="alternate" href="https://panda-wayback.github.io/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"增量式洪水填充算法 (Incremental Flood Fill Algorithm)","item":"https://panda-wayback.github.io/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充"}]}</script><link rel="alternate" type="application/rss+xml" href="/docusaurus-blog/blog/rss.xml" title="Panda 的技术博客 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docusaurus-blog/blog/atom.xml" title="Panda 的技术博客 Atom Feed">




<link rel="alternate" type="application/rss+xml" href="/docusaurus-blog/blog-panda/rss.xml" title="Panda 的技术博客 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docusaurus-blog/blog-panda/atom.xml" title="Panda 的技术博客 Atom Feed"><link rel="stylesheet" href="/docusaurus-blog/assets/css/styles.5f0f2dd1.css">
<script src="/docusaurus-blog/assets/js/runtime~main.87fa75a4.js" defer="defer"></script>
<script src="/docusaurus-blog/assets/js/main.360de741.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/docusaurus-blog/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docusaurus-blog/"><div class="navbar__logo"><img src="/docusaurus-blog/img/logo.svg" alt="Panda 技术博客 Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/docusaurus-blog/img/logo.svg" alt="Panda 技术博客 Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">🐼 Panda Blog</b></a><a class="navbar__item navbar__link" href="/docusaurus-blog/docs/panda-blog/">Panda Blog</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docusaurus-blog/docs/algorithm/">算法</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docusaurus-blog/docs/algorithm/"><span title="算法与工业控制" class="linkLabel_WmDU">算法与工业控制</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docusaurus-blog/docs/algorithm/基础算法/搜索算法/BFS/搜索算法BFS"><span title="基础算法" class="categoryLinkLabel_W154">基础算法</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充"><span title="工业算法" class="categoryLinkLabel_W154">工业算法</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充"><span title="寻路算法" class="categoryLinkLabel_W154">寻路算法</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docusaurus-blog/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充"><span title="增量式洪水填充算法 (Incremental Flood Fill Algorithm)" class="linkLabel_WmDU">增量式洪水填充算法 (Incremental Flood Fill Algorithm)</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docusaurus-blog/docs/algorithm/工业算法/控制算法/ADRC/ADRC简介"><span title="控制算法" class="categoryLinkLabel_W154">控制算法</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/docusaurus-blog/docs/algorithm/工业算法/预测轨迹/卡尔曼滤波"><span title="预测轨迹" class="categoryLinkLabel_W154">预测轨迹</span></a></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docusaurus-blog/docs/algorithm/工业算法总结"><span title="工业算法总结：实用性与设计美学并重的经典算法" class="linkLabel_WmDU">工业算法总结：实用性与设计美学并重的经典算法</span></a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/docusaurus-blog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">工业算法</span></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">寻路算法</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">增量式洪水填充算法 (Incremental Flood Fill Algorithm)</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>增量式洪水填充算法 (Incremental Flood Fill Algorithm)</h1></header>
<blockquote>
<p>📺 <strong>参考视频</strong>: <a href="https://www.bilibili.com/video/BV1Fa4y1w71q/" target="_blank" rel="noopener noreferrer">B站视频链接</a></p>
</blockquote>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-背景介绍">🎯 背景介绍<a href="#-背景介绍" class="hash-link" aria-label="Direct link to 🎯 背景介绍" title="Direct link to 🎯 背景介绍" translate="no">​</a></h2>
<p>增量式洪水填充算法是传统洪水填充算法（Flood Fill Algorithm）的<strong>改进版本</strong>，专门用于处理动态环境中的路径规划问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-传统洪水填充算法">🔍 传统洪水填充算法<a href="#-传统洪水填充算法" class="hash-link" aria-label="Direct link to 🔍 传统洪水填充算法" title="Direct link to 🔍 传统洪水填充算法" translate="no">​</a></h3>
<p>传统的洪水填充算法是一种用于填充连通区域的算法，在路径规划中用于计算每个点到目标的最短距离。</p>
<p><strong>💡 核心逻辑</strong>: 每次遇到墙需要更新数值时，使用BFS从起点更新整个地图距离终点的距离值。</p>
<p><strong>❌ 主要缺点</strong>: 当环境发生变化时（如发现新的障碍物），需要重新计算整个地图的距离场，这在大型地图或频繁变化的环境中效率很低。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-增量式改进">⚡ 增量式改进<a href="#-增量式改进" class="hash-link" aria-label="Direct link to ⚡ 增量式改进" title="Direct link to ⚡ 增量式改进" translate="no">​</a></h3>
<p>增量式洪水填充算法通过**&quot;局部更新&quot;**的思想解决了这个问题。当发现新的障碍物时，算法只更新那些真正受影响的区域，而不是重新计算整个地图。</p>
<p><strong>✅ 核心优势</strong>: 大大提高了算法的效率，特别适合机器人探索、动态路径规划等应用场景。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-应用领域">🚀 应用领域<a href="#-应用领域" class="hash-link" aria-label="Direct link to 🚀 应用领域" title="Direct link to 🚀 应用领域" translate="no">​</a></h3>
<table><thead><tr><th>应用场景</th><th>具体用途</th></tr></thead><tbody><tr><td>🤖 <strong>机器人导航</strong></td><td>实时路径规划</td></tr><tr><td>🎮 <strong>游戏AI</strong></td><td>动态环境中的寻路</td></tr><tr><td>🚗 <strong>自动驾驶</strong></td><td>障碍物检测和路径重规划</td></tr><tr><td>🚁 <strong>无人机导航</strong></td><td>动态避障</td></tr></tbody></table>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-核心思想">💡 核心思想<a href="#-核心思想" class="hash-link" aria-label="Direct link to 💡 核心思想" title="Direct link to 💡 核心思想" translate="no">​</a></h2>
<blockquote>
<p><strong>一句话总结</strong>: 每次遇到墙体，将受影响的点全部搜索到，之后将这些点变成INF（极大值），然后放到队列中BFS，每个点都检查相邻点的值，如果连通就更新值，不连通的就抛出队列。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-增量式洪水填充的核心流程">🔄 增量式洪水填充的核心流程<a href="#-增量式洪水填充的核心流程" class="hash-link" aria-label="Direct link to 🔄 增量式洪水填充的核心流程" title="Direct link to 🔄 增量式洪水填充的核心流程" translate="no">​</a></h3>
<div class="language-mermaid codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mermaid codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">graph TD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    A[遇到墙体] --&gt; B[搜索受影响点]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    B --&gt; C[标记为INF]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    C --&gt; D[BFS更新]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    D --&gt; E[连通则更新]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    E --&gt; F[继续移动]</span><br></span></code></pre></div></div>
<ol>
<li><strong>🏗️ 遇到墙体</strong> → 发现新的障碍物</li>
<li><strong>🔍 搜索受影响点</strong> → 找到所有依赖旧路径的点</li>
<li><strong>⚠️ 标记为INF</strong> → 将这些点设置为极大值（待更新）</li>
<li><strong>🔄 BFS更新</strong> → 将这些点放入队列，检查邻居值</li>
<li><strong>✅ 连通则更新</strong> → 如果找到更短路径就更新，否则跳过</li>
</ol>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-算法执行步骤">📋 算法执行步骤<a href="#-算法执行步骤" class="hash-link" aria-label="Direct link to 📋 算法执行步骤" title="Direct link to 📋 算法执行步骤" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="第一步初始化距离场">第一步：初始化距离场<a href="#第一步初始化距离场" class="hash-link" aria-label="Direct link to 第一步：初始化距离场" title="Direct link to 第一步：初始化距离场" translate="no">​</a></h3>
<p>首先标记每个格子到终点的距离，这一步是理想化的（假设没有障碍物）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="第二步机器人移动">第二步：机器人移动<a href="#第二步机器人移动" class="hash-link" aria-label="Direct link to 第二步：机器人移动" title="Direct link to 第二步：机器人移动" translate="no">​</a></h3>
<p>机器人按照距离递减的方向移动（总是朝着距离更小的方向走）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="第三步发现障碍物时的处理">第三步：发现障碍物时的处理<a href="#第三步发现障碍物时的处理" class="hash-link" aria-label="Direct link to 第三步：发现障碍物时的处理" title="Direct link to 第三步：发现障碍物时的处理" translate="no">​</a></h3>
<p>当遇到一堵墙（障碍物）时，只更新与这个点<strong>相邻且数值连续递增</strong>的所有相关点。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">受影响点 (INF)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">查找四邻居的有效值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果 min + 1 &lt; 当前值：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      → ✅ 更新 + 加入队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">否则：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      → ❌ 丢掉，不更新</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="第四步继续移动">第四步：继续移动<a href="#第四步继续移动" class="hash-link" aria-label="Direct link to 第四步：继续移动" title="Direct link to 第四步：继续移动" translate="no">​</a></h3>
<p>更新完成后，机器人继续按照距离递减的方向移动。</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-局部洪水填充算法局部-bfs-更新逻辑">🔧 局部洪水填充算法（局部 BFS 更新逻辑）<a href="#-局部洪水填充算法局部-bfs-更新逻辑" class="hash-link" aria-label="Direct link to 🔧 局部洪水填充算法（局部 BFS 更新逻辑）" title="Direct link to 🔧 局部洪水填充算法（局部 BFS 更新逻辑）" translate="no">​</a></h2>
<p>当迷宫中的某个位置发现是墙，可能导致一部分路径失效，我们不需要重新填充整个地图，只需进行**&quot;局部更新&quot;**。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-步骤概述">📝 步骤概述<a href="#-步骤概述" class="hash-link" aria-label="Direct link to 📝 步骤概述" title="Direct link to 📝 步骤概述" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="1️⃣-找出受影响点">1️⃣ 找出受影响点<a href="#1️⃣-找出受影响点" class="hash-link" aria-label="Direct link to 1️⃣ 找出受影响点" title="Direct link to 1️⃣ 找出受影响点" translate="no">​</a></h4>
<p>从新发现的墙的相邻点出发，使用 BFS 向外查找。</p>
<p><strong>🔍 查找条件</strong>: 路径值递增的点，这些点是依赖这条旧路径的。</p>
<p>所有这类点都被认为是**&quot;受影响区域&quot;**。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="2️⃣-清除旧路径值">2️⃣ 清除旧路径值<a href="#2️⃣-清除旧路径值" class="hash-link" aria-label="Direct link to 2️⃣ 清除旧路径值" title="Direct link to 2️⃣ 清除旧路径值" translate="no">​</a></h4>
<p>将所有受影响的点的距离值设置为 <strong>INF</strong>（表示路径失效，待更新）。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="3️⃣-初始化队列">3️⃣ 初始化队列<a href="#3️⃣-初始化队列" class="hash-link" aria-label="Direct link to 3️⃣ 初始化队列" title="Direct link to 3️⃣ 初始化队列" translate="no">​</a></h4>
<p>将所有设为 INF 的点加入 BFS 队列，作为局部更新的起点。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="4️⃣-局部-bfs-更新">4️⃣ 局部 BFS 更新<a href="#4️⃣-局部-bfs-更新" class="hash-link" aria-label="Direct link to 4️⃣ 局部 BFS 更新" title="Direct link to 4️⃣ 局部 BFS 更新" translate="no">​</a></h4>
<p>对于队列中的每个点 (x, y)：</p>
<ul>
<li><strong>🔍 找到其四个邻居中 不是墙且不是 INF 的最小值</strong></li>
<li><strong>📊 更新自己的值为：min(邻居值) + 1</strong></li>
<li><strong>🔄 如果成功更新，就将它的邻居加入队列，继续传播</strong></li>
<li><strong>⏸️ 如果邻居都无效（墙或 INF），则跳过，等待邻居先被更新</strong></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-关键点总结">🎯 关键点总结<a href="#-关键点总结" class="hash-link" aria-label="Direct link to 🎯 关键点总结" title="Direct link to 🎯 关键点总结" translate="no">​</a></h3>
<ul>
<li><strong>🎯 只更新&quot;依赖旧路径&quot;的区域</strong>，避免全图计算</li>
<li><strong>🌊 更新逻辑为洪水填充</strong>：最短邻居 + 1</li>
<li><strong>📈 使用 BFS 确保更新顺序</strong>是&quot;由近到远&quot;</li>
<li><strong>🛡️ 可使用 visited/in_queue 等机制</strong>避免重复入队</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-算法伪代码">💻 算法伪代码<a href="#-算法伪代码" class="hash-link" aria-label="Direct link to 💻 算法伪代码" title="Direct link to 💻 算法伪代码" translate="no">​</a></h3>
<div class="language-pseudocode codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-pseudocode codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function 局部洪水填充(障碍物位置):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 步骤1: 找出受影响点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    受影响点集合 = 空集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    队列1 = [障碍物位置]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while 队列1不为空:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        当前点 = 队列1出队()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for 每个相邻点:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if 相邻点数值 = 当前点数值 + 1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                将相邻点加入受影响点集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                将相邻点加入队列1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 步骤2: 清除旧路径值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for 每个受影响点:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        设置距离值为 INF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 步骤3: 初始化队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    更新队列 = 受影响点集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 步骤4: 局部 BFS 更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while 更新队列不为空:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        当前点 = 更新队列出队()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # 找到有效邻居的最小值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        最小值 = INF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for 每个邻居:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if 邻居不是墙 且 邻居不是 INF:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                最小值 = min(最小值, 邻居值)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # 更新当前点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if 最小值 != INF:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            新值 = 最小值 + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if 新值 &lt; 当前点值:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                当前点值 = 新值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # 将邻居加入队列继续传播</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for 每个邻居:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if 邻居不是墙:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        将邻居加入更新队列</span><br></span></code></pre></div></div>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-关键理解">🧠 关键理解<a href="#-关键理解" class="hash-link" aria-label="Direct link to 🧠 关键理解" title="Direct link to 🧠 关键理解" translate="no">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-算法思维特点">🎯 算法思维特点<a href="#-算法思维特点" class="hash-link" aria-label="Direct link to 🎯 算法思维特点" title="Direct link to 🎯 算法思维特点" translate="no">​</a></h3>
<p>洪水填充算法的复杂度思维与普通算法不同：它以<strong>小车快速到达终点</strong>为评判标准，实际效果是在有限的探索范围内，小车可以快速到达终点。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-什么是数值连续">❓ 什么是&quot;数值连续&quot;？<a href="#-什么是数值连续" class="hash-link" aria-label="Direct link to ❓ 什么是&quot;数值连续&quot;？" title="Direct link to ❓ 什么是&quot;数值连续&quot;？" translate="no">​</a></h3>
<p>在距离场中，每个点的数值表示到目标的最短距离。</p>
<p><strong>📊 数值连续</strong>的意思是：</p>
<ul>
<li>如果障碍物位置的数值是 <strong>3</strong></li>
<li>那么<strong>与它相邻且数值为 4</strong> 的点都与它相关</li>
<li>然后继续找与这些点相邻且数值为 <strong>5</strong> 的点</li>
<li>以此类推，形成一条**&quot;数值连续递增&quot;**的路径</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-为什么只更新这些点">🤔 为什么只更新这些点？<a href="#-为什么只更新这些点" class="hash-link" aria-label="Direct link to 🤔 为什么只更新这些点？" title="Direct link to 🤔 为什么只更新这些点？" translate="no">​</a></h3>
<table><thead><tr><th>点的数值</th><th>更新原因</th><th>处理方式</th></tr></thead><tbody><tr><td><strong>1、2的点</strong></td><td>最短路径不经过障碍物</td><td>✅ 无需更新</td></tr><tr><td><strong>与障碍物相邻且数值连续递增的点</strong></td><td>最短路径经过障碍物</td><td>🔄 需要重新计算</td></tr></tbody></table>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-算法步骤总结">📋 算法步骤总结<a href="#-算法步骤总结" class="hash-link" aria-label="Direct link to 📋 算法步骤总结" title="Direct link to 📋 算法步骤总结" translate="no">​</a></h2>
<div class="language-mermaid codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mermaid codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">graph LR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    A[发现障碍物] --&gt; B[找出受影响点]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    B --&gt; C[清除旧路径值]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    C --&gt; D[初始化更新队列]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    D --&gt; E[局部BFS更新]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    E --&gt; F[传播更新]</span><br></span></code></pre></div></div>
<ol>
<li><strong>🔍 发现障碍物</strong> → 记录障碍物位置</li>
<li><strong>🎯 找出受影响点</strong> → 从障碍物开始BFS，找到所有数值连续递增的依赖点</li>
<li><strong>🗑️ 清除旧路径值</strong> → 将所有受影响点的距离值设置为INF</li>
<li><strong>🚀 初始化更新队列</strong> → 将所有INF点加入BFS队列作为起点</li>
<li><strong>🔄 局部BFS更新</strong> → 从队列中的点开始，按&quot;最短邻居+1&quot;规则更新</li>
<li><strong>📈 传播更新</strong> → 将更新后的点的邻居加入队列继续传播</li>
</ol>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-性能优势">⚡ 性能优势<a href="#-性能优势" class="hash-link" aria-label="Direct link to ⚡ 性能优势" title="Direct link to ⚡ 性能优势" translate="no">​</a></h2>
<table><thead><tr><th>方法</th><th>时间复杂度</th><th>适用场景</th><th>效率</th></tr></thead><tbody><tr><td>🐌 传统方法</td><td>O(地图大小)</td><td>静态地图</td><td>低</td></tr><tr><td>🚀 增量方法</td><td>O(相关点数量)</td><td>动态地图</td><td>高</td></tr></tbody></table>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-总结">🎯 总结<a href="#-总结" class="hash-link" aria-label="Direct link to 🎯 总结" title="Direct link to 🎯 总结" translate="no">​</a></h2>
<blockquote>
<p><strong>发现障碍物 → 找出受影响点 → 清除旧路径值 → 局部BFS更新</strong></p>
</blockquote>
<p>这就是增量式洪水填充的精髓：</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-核心特点">🌟 核心特点<a href="#-核心特点" class="hash-link" aria-label="Direct link to 🌟 核心特点" title="Direct link to 🌟 核心特点" translate="no">​</a></h3>
<ol>
<li><strong>🎯 通过数值连续性</strong>判断路径依赖关系</li>
<li><strong>⚡ 只更新真正受影响的区域</strong>，避免全图重新计算</li>
<li><strong>🔄 使用局部BFS</strong>确保更新顺序正确</li>
<li>**🌊 采用&quot;最短邻居+1&quot;**的洪水填充逻辑</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-核心优势">🚀 核心优势<a href="#-核心优势" class="hash-link" aria-label="Direct link to 🚀 核心优势" title="Direct link to 🚀 核心优势" translate="no">​</a></h3>
<p>当环境发生局部变化时，只需要更新一小部分区域，大大提高了算法的效率。算法的实际效果是：<strong>在有限的探索范围内，小车可以快速到达终点</strong>。</p>
<hr>
<p><em>📝 这种增量式方法特别适合需要实时响应的动态环境，是传统洪水填充算法的重要改进。</em></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/algorithm/工业算法/寻路算法/Flood Fill 洪水填充.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docusaurus-blog/docs/algorithm/基础算法/搜索算法/DFS/搜索算法DFS"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">搜索算法DFS</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docusaurus-blog/docs/algorithm/工业算法/控制算法/ADRC/ADRC简介"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ADRC 自抗扰控制器简介</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-背景介绍" class="table-of-contents__link toc-highlight">🎯 背景介绍</a><ul><li><a href="#-传统洪水填充算法" class="table-of-contents__link toc-highlight">🔍 传统洪水填充算法</a></li><li><a href="#-增量式改进" class="table-of-contents__link toc-highlight">⚡ 增量式改进</a></li><li><a href="#-应用领域" class="table-of-contents__link toc-highlight">🚀 应用领域</a></li></ul></li><li><a href="#-核心思想" class="table-of-contents__link toc-highlight">💡 核心思想</a><ul><li><a href="#-增量式洪水填充的核心流程" class="table-of-contents__link toc-highlight">🔄 增量式洪水填充的核心流程</a></li></ul></li><li><a href="#-算法执行步骤" class="table-of-contents__link toc-highlight">📋 算法执行步骤</a><ul><li><a href="#第一步初始化距离场" class="table-of-contents__link toc-highlight">第一步：初始化距离场</a></li><li><a href="#第二步机器人移动" class="table-of-contents__link toc-highlight">第二步：机器人移动</a></li><li><a href="#第三步发现障碍物时的处理" class="table-of-contents__link toc-highlight">第三步：发现障碍物时的处理</a></li><li><a href="#第四步继续移动" class="table-of-contents__link toc-highlight">第四步：继续移动</a></li></ul></li><li><a href="#-局部洪水填充算法局部-bfs-更新逻辑" class="table-of-contents__link toc-highlight">🔧 局部洪水填充算法（局部 BFS 更新逻辑）</a><ul><li><a href="#-步骤概述" class="table-of-contents__link toc-highlight">📝 步骤概述</a></li><li><a href="#-关键点总结" class="table-of-contents__link toc-highlight">🎯 关键点总结</a></li><li><a href="#-算法伪代码" class="table-of-contents__link toc-highlight">💻 算法伪代码</a></li></ul></li><li><a href="#-关键理解" class="table-of-contents__link toc-highlight">🧠 关键理解</a><ul><li><a href="#-算法思维特点" class="table-of-contents__link toc-highlight">🎯 算法思维特点</a></li><li><a href="#-什么是数值连续" class="table-of-contents__link toc-highlight">❓ 什么是&quot;数值连续&quot;？</a></li><li><a href="#-为什么只更新这些点" class="table-of-contents__link toc-highlight">🤔 为什么只更新这些点？</a></li></ul></li><li><a href="#-算法步骤总结" class="table-of-contents__link toc-highlight">📋 算法步骤总结</a></li><li><a href="#-性能优势" class="table-of-contents__link toc-highlight">⚡ 性能优势</a></li><li><a href="#-总结" class="table-of-contents__link toc-highlight">🎯 总结</a><ul><li><a href="#-核心特点" class="table-of-contents__link toc-highlight">🌟 核心特点</a></li><li><a href="#-核心优势" class="table-of-contents__link toc-highlight">🚀 核心优势</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docusaurus-blog/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docusaurus-blog/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Panda 的技术博客. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>